\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{titling}
\usepackage[top=2cm,
    		bottom=2cm,
    		left=2cm,
    		right=2cm]{geometry}
\usepackage{algorithm, algpseudocode} % Do not put both alhpseudocode and algorithmic because ovewrite the same command.
\usepackage{hyperref}


\graphicspath{{figures/}}



\title{\textbf{Scalability and Communication Overhead in Distributed N-Body Simulation using MPI on GCP}\\}
\author{Claudio Guarrasi\\[1ex]}
\date{%
	\today
	\vspace{-0.25cm}
	\\
	\rule{\textwidth}{0.3pt}}


% Subtitle above title (use \pretitle)
\pretitle{%
  \begin{center}
  	\vspace{-3cm} %vertical distance between upper margin and the logo. A negative value means that I am trying to get them closer.
  	\hspace*{0.1cm} %moving it on the right-
    \includegraphics[width=0.3\textwidth]{black_unipv_logo_caption_below.png}					\rule{\textwidth}{0.3pt}
    \textit{Advanced Computer Architecture}\\[1ex]
    \Large  % Switch to large font for the title
}
\posttitle{%
	\end{center} % Close centering.
	}

\preauthor{\begin{center}}
\postauthor{%
	\small{Department of Electrical, Computer and Biomedical Engineering}\\
	\small{University of Pavia}\\[1ex]
	\small{Email: \href{mailto:claudio.guarrasi01@universitadipavia.it}{claudio.guarrasi01@universitadipavia.it}}\\
	\small{GitHub: \href{https://github.com/PapiDrago/n-body-problem}{\underline{https://github.com/PapiDrago/n-body-problem}}}
	\end{center}}






\begin{document}
\begin{titlingpage}

\maketitle %thanks to 'titling' package, this command generates also the 'pretitle' and 'posttitle', the 'preauthor' and 'postauthor' and the 'predate' and 'postdate' and put them in the following order: {\pretitle, \title, \posttitle, \preauthor, \author, \postauthor, \predate, \date, \postdate} (\maketitle has been overwritten in the package)
\thispagestyle{empty} % It goes after \maketitle and not after \begin{titlingpage} because \maketitle creates a new page and reset that setting.

	\begin{multicols*}{2}

		\begin{abstract}
			\centering
			\noindent
			This report presents a comprehensive overview of the methods, challenges, and potential solutions involved in the development of a modern technical system. The work includes an analysis of the underlying concepts, a review of relevant literature, and an evaluation of current approaches. Emphasis is placed on both theoretical foundations and practical implementation strategies. The results obtained highlight the effectiveness of the chosen methodology and provide a solid basis for future research or application. This abstract serves as a placeholder and should be replaced with a summary specific to the final version of the report.
		\end{abstract}
	\newcolumn
		\centering
		\noindent
		\tableofcontents
	\end{multicols*}
\end{titlingpage}

\thispagestyle{plain}
%\pagenumbering{arabic}

\twocolumn

\section{Introduction}
\label{sec:intro}
The N-body problem is a well-known problem in physics and it has several applications ranging from modeling the gravitational interactions in galaxies and solar systems to simulating charged particle dynamics in plasmas and atoms in molecular systems.

Depending on the goal of the analysis, various assumptions can be relaxed or adjusted. In the experiments I conducted, I considered a closed system of $N$ point masses interacting solely through gravitational forces. This assumption is quite reasonable when modeling astronomical systems, especially when the goal is to compute the trajectories of celestial bodies within them. In such systems, the gravitational force dominates due to the extremely large masses involved, allowing other forces to be safely neglected.

Numerous algorithmic solutions have been proposed to address the N-body problem, many of which have been implemented in software to automate the computation of relevant physical quantities.

This work does not aim to propose a new or improved algorithmic solution. Instead, given an existing approach, the focus is on developing a parallel implementation that highlights the complexities involved in distributing the computation and evaluates its performance in a distributed environment.

Essentially the objectives of this work were:
\begin{enumerate}
\item to analyze a possible serial algorithm for solving the N-body problem;
\item to perform an \emph{a priori} study of the available parallelism using Amdahl's Law;
\item to develop a parallel implementation using the Message Passing Interface (MPI);
\item to evaluate performance and scalability through experiments conducted on Google Cloud Platform (GCP).
\end{enumerate}

\section{Physical Model}
In order to understand the algorithm it is important to recall the physics laws on which the model is based.
\begin{itemize}
\item Newton's law of universal gravitation:
\begin{equation}
\vec{F}_{i,j}=G\frac{m_{i} m_{j}}{\|\vec{r}_{i}-\vec{r}_{j}\|^3}(\vec{r}_{j}-\vec{r}_{i})
\label{eq:gravitation}
\end{equation}
\begin{description}
    \item[\( G \)] Gravitational constant.
    \item[\( m_i, m_j \)] Masses of bodies \( i \) and \( j \).
    \item[\( \vec{r}_i, \vec{r}_j \)] Position vectors of bodies \( i \) and \( j \).
    \item[\( \vec{F}_{i,j} \)] Force acting on body \( i \) due to body \( j \).
\end{description}
Please note that $\vec{F}_{i,j}$ is an attractive force that has the same direction of the displacement vector \mbox{$(\vec{r}_j - \vec{r}_i)$}.
\item Newton's second law of motion:
\begin{equation}
\Sigma\vec{F} = m\vec{a}
\label{eq:motion}
\end{equation}
It states that the sum of all the forces $\Sigma\vec{F}$ acting on a particular point mass is equal to the product between its mass $m$ and its acceleration $\vec{a}$.
\end{itemize}
In our scenario we can combine~\eqref{eq:gravitation} and~\eqref{eq:motion} to obtain, at a certain time instant, the acceleration $\vec{a}_i$ of point mass $i$ implied by all the gravitational forces acting on that point mass. Analytically we can write:
\begin{equation}
\vec{a}_i=\sum_{\substack{j=0 \\ j \neq i}}^{N-1}\left[G\frac{m_j}{\|\vec{r}_i-\vec{r}_j\|^3}(\vec{r}_j-\vec{r}_i)\right]
\label{eq:acceleration}
\end{equation}
Since we are ultimately interested in the trajectory of each body, from $\vec{a}_i$ we can compute the velocity $\vec{v}_i$ and the position $\vec{r}_i$ of mass $i$ by simply integrating $\vec{a}_i$ with respect to time.
\begin{equation}
\vec{v}_i(t_k) = \vec{v}_i(t_{k-1}) + \int_{t_{k-1}}^{t_k} \vec{a}_i(\tau)\, d\tau
\label{eq:continuous_v}
\end{equation}
\begin{equation}
\vec{r}_i(t_k) = \vec{r}_i(t_{k-1}) + \int_{t_{k-1}}^{t_k} \vec{v}_i(\tau)\, d\tau
\label{eq:continuous_r}
\end{equation}
\begin{description}
\item $t_{k-1}$ Time instant defining the initial condition for the current time step.
\end{description}
Although the notation $t_k$ and $t_{k-1}$ may initially appear cumbersome, it will prove useful later when expressing the iterative numerical formulation of the problem.
\subsection{Iterative Nature of the N-body Solution}
It is important to note that for systems involving more than two bodies (\( N > 2 \)), the N-body problem does not admit a general closed-form solution. This means that it is not possible to determine the complete trajectories of all bodies analytically from the initial conditions alone.

In the special case \( N = 2 \), the problem can be reduced to a one-body system by moving to the center-of-mass reference frame. In this frame, the motion can be fully described using relative coordinates, and a closed-form analytical solution can be derived for the position and velocity of each body. However, as soon as a third body is introduced, the system becomes non-linear and highly sensitive to initial conditions, making analytical solutions intractable in the general case~\cite{heggie2005classical}.

For this reason to compute the position of one particular mass at time $k$ it is necessary to iteratively solve the equations of motion (\eqref{eq:acceleration},\eqref{eq:continuous_v},\eqref{eq:continuous_r}) for all the $N$ bodies at each time step $t \leq k$. This is required because, as shown in \eqref{eq:acceleration}, the acceleration at time $k$ depends on the positions of all the bodies at that time.
Just from this consideration we can already anticipate the high computational cost.

\subsection{Numerical Integration}
At each simulation step, we must numerically integrate the equations of motion in order to update the velocity and position of all bodies. In the continuous-time domain, this corresponds to evaluating \eqref{eq:continuous_v} and \eqref{eq:continuous_r}.

However, in practice a digital computer can only work with discrete time instants due to its inherent limitations: it operates at a finite clock frequency, stores only a finite number of samples in memory, and uses finite-precision arithmetic. As a result, we reformulate the problem in the discrete-time domain.

For convenience, the vector notation is omitted here. The time-discretized velocity update equation can be expressed as:
\begin{equation} % '&' is used as alignment point.
\left\{
\begin{aligned}
\frac{v_{k+1}-v_k}{\Delta t} &= a_k(r_k, k) \\
v_k &=v(k \Delta t)
\end{aligned}
\right.
\end{equation}
\begin{description}
\item[$v_k$] Velocity at time $t_k$, with $t_k = k \, \Delta t$.
\item[$a_k(r_k, k)$] Acceleration at step $k$, computed from \eqref{eq:acceleration}.
\item[$\Delta t$] Step size between two consecutive time instants.
\end{description}
With some little algebraic manipulations we can obtain:
\begin{equation}
v_{k+1}=v_k+a_k\Delta t
\label{eq:v_explicit_euler}
\end{equation}
Similarly, the position update is:
\begin{equation}
r_{k+1}=r_k+v_k\Delta t
\label{eq:r_explicit_euler}
\end{equation}
Incidentally, we expressed position and velocity using the explicit Euler method~\cite{atkinson1989introduction}.

However, not all numerical integration methods are equally suitable when simulating physical systems on a computer. This can be seen by writing the exact velocity at time step $k+1$ using the Taylor expansion with Lagrange remainder:
\begin{equation}
\begin{aligned}
v(t_k+\Delta t) = v(t_k) + a(&t_k)\,\Delta t
+ \frac{\Delta t^2}{2} \frac{d^2 v}{dt^2}(\xi), \\
&\qquad \xi \in \left[ t_k,\, t_k+\Delta t \right]
\end{aligned}
\label{eq:v_taylor}
\end{equation}
Neglecting the second-order term yields \eqref{eq:v_explicit_euler}. This highlights that any numerical integration method produces an approximation, and in the case of explicit Euler, the local truncation error is proportional to $\Delta t^2$.

Choosing a very small $\Delta t$ reduces the error but increases the computational cost.
For example, if $\Delta t = 0.01\,\text{s}$, simulating one second of motion requires $100$ iterations of the solution algorithm, whereas with $\Delta t = 0.1\,\text{s}$, only $10$ iterations are needed.

It also crucial to address the fact that, iteration after iteration, the numerical error accumulates, bringing the computed velocity to deviate more and more from the true value, which in turn causes the total energy of the simulated system to drift, violating the thermodynamical principle of energy conservation.
For the N-Body system described in section~\ref{sec:intro}, this can be seen by considering the total kinetic energy $K_{\text{TOT}}$ of the system at time step $k$:
\begin{equation}
K_{TOT}(k) = \frac{1}{2} \sum_{i=0}^{N-1}m_iv_i^2(k)
\end{equation}
Since the system is closed, this quantity should remain constant during the simulation. However, due to the impossibility of computing the exact velocities, this condition cannot be perfectly satisfied.
What can be done instead is to bound the energy oscillations around the true value.
It can be proven that a \emph{symplectic} numerical methods allows us to achieve this~\cite{ENGLE2005432}.

It is for this reason that I chose to pick for my project the \emph{semi-implicit Euler} integration method, which is symplectic \cite{cioaca2013impactexplicitsemiimplicitintegration}, and very similar to explicit Euler method. The only difference is that to compute the position at time step $k+1$ we use the updated velocity $v_{k+1}$ and not the velocity at the previous time step $k$ as seen in \ref{eq:v_explicit_euler}:
\begin{equation}
r_{k+1}=r_k+v_{k+1} \, \Delta t
\label{eq:v_semi_implicit}
\end{equation}

\section{Serial Algorithm}
In the literature~\cite{heggie2005classical}, several approaches have been proposed to address the N-body problem, each with different computational complexities and levels of approximation.  
In this project, the \emph{direct method} was chosen, as it most closely reflects the conceptual formulation of the problem without making further approximations.

Algorithm~\ref{alg:serial} shows the basic structure of the direct method: initially all the $N$ bodies are initialized. Each of them has mass, a starting position and a starting velocity. Then, for each simulation step, the kinematic quantities are updated. 

\begin{algorithm}[H]
\caption{Serial N-body algorithm (direct method)}
\label{alg:serial}
\begin{algorithmic}[1]
\State Initialize positions, velocities, and masses
\For{each time step}
    \State Compute accelerations (Algorithm~\ref{alg:inner_loop})
    \State Update velocities
    \State Update positions
\EndFor
\end{algorithmic}
\end{algorithm}

\subsection{Complexity Analysis}

\subsubsection{Time Complexity}
The overall time complexity is dominated by the \emph{Compute accelerations} algorithm~\ref{alg:inner_loop}, since the other components of the serial algorithm involve only a single loop over the $N$ bodies ($N$ is the problem size). In contrast, the \emph{Compute accelerations} step contains a nested loop that also iterates over all $N$ bodies (in practice $N-1$, which is asymptotically equivalent to $N$). 

More precisely, the actual computational cost also depends on the number of time steps $T$ in the simulation, leading to a total complexity of $O(T N^2)$.

Since in the experiments conducted $N \gg T$, the factor $T$ will be omitted from the complexity expressions in the remainder of this work.

\begin{algorithm}
\caption{Inner loop: compute accelerations (direct method)}
\label{alg:inner_loop}
\begin{algorithmic}[1]
\Require Positions $\{\vec r_j\}_{j=0}^{N-1}$, masses $\{m_j\}_{j=0}^{N-1}$
\Ensure Accelerations $\{\vec a_i\}_{i=0}^{N-1}$
\For{$i \gets 0$ to $N-1$}
  \State $\vec a_i \gets (0,0,0)$
  \For{$j \gets 0$ to $N-1$}
    \If{$j \neq i$}
      \State $\vec d \gets \vec r_j - \vec r_i$
      \State $R^3 \gets \|\vec d\|^3 $
      \State $invR^3 \gets 1 /R^3$
      \State $\vec a_i \gets \vec a_i + G \, m_j \, invR^3 \, \vec d$
    \EndIf
  \EndFor
\EndFor
\Statex \textbf{Time complexity:} $O(N^2)$
\end{algorithmic}
\end{algorithm}

\subsubsection{Space Complexity}
The serial algorithm requires storing the masses, the positions, the velocities and the accelerations of the $N$ bodies. Since the kinematic quantities are 3D vectors, each elements corresponds to 3 floating-point values.
This means the total storage is:

This means the total storage is: %aligne is a math environment
\begin{align*}
&N \ \text{masses} + 3N \ \text{positions} + 3N \ \text{velocities} \\
&\quad + 3N \ \text{accelerations} = 10N \ \text{real values}
\end{align*}

Asymptotically, this results in a space complexity of $O(N)$.  

On modern general-purpose computers, this is not a limiting factor because several gigabytes of RAM are available. For example, if double precision is used (8 bytes per floating-point number), one million bodies would require:
\[
8 \times 10 \times 10^6 = 80 \ \text{MB}
\]
which easily fits in memory.

\subsection{Implementation in C}
The conceptual serial algorithm described in the previous subsection was implemented in the C programming language. This choice was primarily motivated by the need to perform detailed profiling of the code. The complete source code is publicly available on the GitHub repository for this project\footnote{\url{https://github.com/PapiDrago/n-body-problem}, file \emph{serial.c}}.

The implementation follows closely the structure of Algorithm~\ref{alg:serial}, with each major step of the simulation (initialization, acceleration computation, velocity update, and position update) mapped to dedicated functions.
This modular structure facilitates both readability and profiling, enabling the identification of computational bottlenecks.  

%Passa in rassegna le funzioni sottolineando la struttura del vettore. Da menzionare che all'inizio l'input consisteva nella lettura di un file di testo ciò mi permetteva di forzare arbitrariamente i valori iniziali dei corpi per confermare l'efficacia dell'algoritmo. A proposito l'applicazione seriale stampa al termine di ogni passo della simulazione le coordinate dei corpi. Il file contenenente le coordinate è stato dato a un'app python per avere un'animazione della traiettoria dei corpi in modo tale che tutto torni. Mostra sistema solare e magari anche la maggiore velocità di un corpo quando si avvicina a un corpo più grande. Poi dire perché ho fatto l'inizializzazione a caso. Confermare la time complexity con grafico. Quindi iniziare a discutere il profiling, sottolineare quale sia il bottleneck e ...
%
\bibliographystyle{IEEEtran} %I had to install a package through the package manager to use 'IEEEtran'.
\bibliography{refs} 
\end{document}
